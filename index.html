<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Love11zi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Love11zi's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Love11zi's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Love11zi's Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Love11zi&#39;s Blog" type="application/atom+xml">
  
  
    <!-- <link rel="icon" href="/favicon.png"> -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Love11zi&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Javascript标准参考教材摘记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/06/Javascript标准参考教材摘记/" class="article-date">
  <time datetime="2015-03-06T06:28:21.000Z" itemprop="datePublished">2015-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/Javascript标准参考教材摘记/">Javascript标准参考教材摘记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言">前言</h2><p>略</p>
<h2 id="基本语法">基本语法</h2><ul>
<li>变量提升只针对var命令声明的</li>
<li>switch结构不利于代码重用，往往可以用对象形式重写</li>
<li>break语句用于跳出代码块或循环，continue语句用于立即终止本次循环，返回循环结构的头部，开始下一次循环，存在多重循环，不带参数的break语句和continue语句都只针对最内层循环</li>
<li><p>JavaScript语言允许，语句的前面有标签（label）。标签通常与break语句和continue语句配合使用，跳出特定的循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i===<span class="number">1</span> &amp;&amp; j===<span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"i="</span>+i+<span class="string">",j="</span>+j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript的所有数据，都可以视为对象。</p>
</li>
<li>原始类型包括三种数据类型。数值（number）字符串（string）布尔值（boolean）</li>
<li>合成类型也包括三种数据类型 对象（object）数组（array）函数（function）</li>
<li>除了上面这六个类别，JavaScript还定义了两个特殊值null和undefined。</li>
<li>JavaScript有三种方法，可以确定一个值到底是什么类型。typeof instanceof Object.prototype.toString</li>
<li>typeof可以用来检查一个没有声明的变量，而不报错 typeof undefined “undefined”</li>
<li>typeof可检测数值（number）字符串（string）布尔值（boolean）函数（function），其余都返回”object”</li>
<li>除了下面六个值被转为false，其他值都视为true。undefined null false 0 NaN “”（空字符串）</li>
<li>空数组（[]）和空对象（{}）对应的布尔值，都是true</li>
<li>一般来说，在没有分号结尾的情况下，如果下一行起首的是(、 [ 、+、-、/这五个字符中的一个，分号不会被自动添加。只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript引擎才会自动添加分号。</li>
<li>本质上，数组也属于对象，是字典结构（dictionary）的一个变种。</li>
<li>数组成员最多只有4294967295个（232-1）个，也就是说length属性的最大值就是4294967295。</li>
<li>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。但是，这种写法有两个注意点，首先，它是ECMAScript 5新添加的，老式浏览器（如IE 8）不支持，其次，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</li>
<li>反斜杠在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。如\r 回车键，\ 反斜杠。如果非特殊字符前面使用反斜杠，则反斜杠会被省略。</li>
<li>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符。如’hello’[1] == ‘e’.字符串与数组的相似性仅此而已。实际上，字符串是类似数组的对象</li>
<li>JavaScript使用Unicode字符集</li>
<li>每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为2个字节。</li>
<li>Base64是一种将二进制数据转为可打印字符的编码方法。window.btoa(“Hello World”)</li>
<li>JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</li>
<li>JavaScript能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。如果指数部分等于或超过最大正值1024，JavaScript会返回Infinity</li>
<li>NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。typeof NaN // ‘number’ NaN不等于任何值，包括它本身。</li>
<li>isFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity。</li>
<li>parseInt 如果字符串的第一个字符不能转化为数字（正负号除外），返回NaN。</li>
<li>parseFloat用于将一个字符串转为浮点数。</li>
<li>如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个变量是否被声明。后二种写法有漏洞，如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。正确的写法是使用in运算符。</li>
<li>查看一个对象本身的所有属性，可以使用Object.keys方法。</li>
<li>如果只想遍历对象本身的属性，可以使用hasOwnProperty方法</li>
<li>Array.prototype.slice.call(arguments)将类似数组的对象，变成真正的数组</li>
<li>函数声明（Function Declaration）&amp; 函数表达式（Function Expression）</li>
<li><p>函数可以调用自身，这就是递归（recursion）如计算斐波那契数列</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fib(num - <span class="number">2</span>) + fib(num - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(<span class="number">6</span>)</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义</p>
</li>
<li>由于存在函数名的提升，所以在条件语句中声明函数是无效的，这是非常容易出错的地方</li>
<li>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</li>
<li>函数的length属性与实际传入的参数个数无关，只反映定义时的参数个数。</li>
<li>立即调用的函数表达式（IIFE）</li>
<li>加法运算符以外的其他算术运算符，都不会发生重载。它们的规则是：所有运算子一律转为数值.如 1 - “1” // 0</li>
<li>自增/自减运算符就是放在变量之后，表示先返回变量操作前的值，再进行递增/递减操作；放在变量之前，表示先进行递增/递减操作，再返回变量操作后的值</li>
<li>数值运算符（+）是一元运算符（只需要一个操作数）。重要作用在于可以将任何值转为数值（与Number函数的作用相同）</li>
<li>undefined 和 null 与自身严格相等。</li>
<li>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。</li>
<li>对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。</li>
<li>undefined == null // true</li>
<li>三元条件表达式与if…else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if…else是语句，没有返回值；三元条件表达式是表达式，具有返回值。<br>-Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN</li>
<li>try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。</li>
<li>Uint8Array 数字数组,初始会把各项转换为8位数字</li>
</ul>
<h2 id="标准库">标准库</h2><ul>
<li>所有构造函数都有一个prototype属性，指向一个原型对象。凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享。</li>
<li><p>要在Object对象上面部署一个方法，有两种做法:</p>
<p>1.部署在Object对象本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.print = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span>&#123; <span class="built_in">console</span>.log(o) &#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.print(o)</span><br></pre></td></tr></table></figure>
<p>2.部署在Object.prototype对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.print = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.print() <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
<p>必须区分“构造函数的方法”和“实例对象的方法”。</p>
</li>
<li><p>如果Object函数的参数是一个对象，它总是返回原对象。利用这一点，可以写一个判断变量是否为对象的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="built_in">Object</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.keys()，Object.getOwnPropertyNames()用来遍历对象的属性。它们的参数都是一个对象，都返回一个数组，该数组的成员都是对象自身的（而不是继承的）所有属性名。它们的区别在于，Object.keys方法只返回可枚举的属性</p>
</li>
<li>Object.observe方法用于观察对象属性的变化</li>
<li>Object.defineProperty()：通过attributes对象，定义某个属性</li>
<li>Object.preventExtensions()：防止对象扩展 使得一个对象无法再添加新的属性。</li>
<li>Object.seal()：禁止对象配置。 既无法添加新属性，也无法删除旧属性。</li>
<li>Object.freeze()：冻结一个对象。</li>
<li>除了Object对象本身的方法，还有不少方法是部署在Object.prototype对象上的，所有Object的实例对象都继承了这些方法。</li>
<li>Object实例对象的方法，主要有以下六个<code>valueOf()</code> <code>toString()</code> <code>toLocalString()</code> <code>hasOwnProperty()</code> <code>isPrototypeOf()</code> <code>propertyIsEnumerable()</code></li>
<li>Object.prototype.toString方法，从而帮助我们判断这个值的类型</li>
<li>Array对象的静态方法 isArray方法</li>
<li>Array对象实例的方法<ul>
<li>concat方法将新数组的成员，添加到原数组的尾部，然后返回一个新数组，常用于连接多个数组</li>
<li>reverse方法用于颠倒数组中元素的顺序</li>
<li>slice方法返回指定位置的数组成员组成的新数组，原数组不变.第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）如果省略第二个参数，则一直返回到原数组的最后一个成员。，如果slice方法的参数是负数，则从尾部开始选择的成员个数</li>
<li>slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</li>
<li>splice方法用于删除元素，并可以在被删除的位置添加入新的数组元素。它的返回值是被删除的元素。需要特别注意的是，该方法会改变原数组。splice的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</li>
<li>sort方法对数组元素进行排序</li>
<li>ECMAScript 5新增了9个数组实例的方法，分别是map、forEach、filter、every、some、reduce、reduceRight、indexOf和lastIndexOf</li>
</ul>
</li>
<li>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</li>
<li>Number对象实例的方法<ul>
<li><code>toString</code>可以接受一个参数，表示将一个数字转化成某个进制的字符串</li>
<li><code>toFixed()</code>用于将一个数转为指定位数的小数</li>
<li><code>toExponential</code>将一个数转为科学计数法形式</li>
<li><code>toPrecision</code> 将一个数转为指定位数的有效数字</li>
</ul>
</li>
<li>String对象直接提供的方法，主要是fromCharCode()。该方法根据Unicode编码，生成一个字符串。</li>
<li>charAt方法返回一个字符串的给定位置的字符,可以用数组下标替代</li>
<li>charCodeAt方法返回给定位置字符的Unicode编码</li>
<li>concat方法用于连接两个字符串</li>
<li>substring方法，substr方法和slice方法都用来返回一个字符串的子串，而不会改变原字符串</li>
<li>substring方法的第一个参数表示子字符串的开始位置，第二个位置表示结束结果。因此，第二个参数应该大于第一个参数。如果出现第一个参数大于第二个参数的情况，substring方法会自动更换两个参数的位置。</li>
<li>substr方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。</li>
<li>slice方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置。与substring方法不同的是，如果第一个参数大于第二个参数，slice方法并不会自动调换参数位置，而是返回一个空字符串</li>
<li>indexOf 和 lastIndexOf 方法 它们还可以接受第二个参数，对于indexOf，表示从该位置开始向后匹配；对于lastIndexOf，表示从该位置起向前匹配。</li>
<li>trim 方法用于去除字符串两端的空格</li>
<li>toLowerCase 和 toUpperCase</li>
<li>match：用于确定原字符串是否匹配某个子字符串，返回匹配的子字符串数组。</li>
<li>search：等同于match，但是返回值不一样。</li>
<li>replace：用于替换匹配的字符串。</li>
<li>split：将字符串按照给定规则分割，返回一个由分割出来的各部分组成的新数组。</li>
<li>无论有没有参数，直接调用Date总是返回当前时间</li>
<li>Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数</li>
<li>window.performance.now()。它提供页面加载到命令运行时的已经过去的时间，单位是浮点数形式的毫秒。</li>
<li>RegExp对象的lastIndex</li>
<li>exec方法返回匹配结果 如果匹配成功，exec方法返回一个数组，里面是匹配结果。如果匹配失败，返回null。exec方法的返回数组还包含以下两个属性：input：整个原字符串。index：整个模式匹配成功的开始位置。如果正则表示式包含圆括号，则返回的数组会包括多个元素。其中，第一个元素是整个匹配成功的结果，后面的元素就是圆括号对应的匹配成功的组，也就是说第二个元素就对应第一个括号，第三个元素对应第二个括号，以此类推。整个返回数组的length属性等于匹配成功的组数+1。</li>
<li>字符串对象的方法之中，有4种与正则对象有关。</li>
<li>字符串的match方法与正则对象的exec方法非常类似。如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会返回所有匹配成功的结果。</li>
<li>search 类似 test</li>
<li>replace方法可以替换匹配的值，它接受两个参数，第一个是搜索模式，第二个是替换的内容。搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。eplace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。第二个参数还可以是一个函数，将匹配内容替换为函数返回值</li>
<li>$&amp; 指代匹配的子字符串。$<code> </code> 指代匹配结果前面的文本。$’指代匹配结果后面的文本。$n 指代匹配成功的第n组内容，n从1开始计数。$$ 指代美元符号$。</li>
<li>正则<ul>
<li>点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</li>
<li>位置字符用来提示字符所处的位置，主要有两个字符。^ 表示字符串的起首。$ 表示字符串的行尾。</li>
<li>竖线符号（|）在正则表达式中表示“或关系”（OR）</li>
<li>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内</li>
<li>如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</li>
<li>对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。[1-31]，不代表1到31，只代表1到3</li>
<li>{} 表示模式的重复次数。{n}表示重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次</li>
<li>量词符 ? 表示某个模式出现1次或0次，等同于{0, 1}。* 表示某个模式出现0次或多次，等同于 {0,}。 + 表示某个模式出现1次或多次，等同于 {1,}。默认情况下的匹配规则都是贪婪模式，为了将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号，/a+?/将会只匹配“a”。</li>
<li>正则模式中，需要用斜杠转义的，一共有12个字符：<code>^、.、[、$、(、)、|、*、+、?、{和 \。</code><br>需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</li>
<li>\d 匹配0-9之间的任一数字，相当于[0-9]。<br>\D 匹配所有0-9以外的字符，相当于[^0-9]。<br>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9<em>]。<br>\W 除所有字母、数字和下划线以外的字符，相当于/[^A-Za-z0-9</em>]/ 。<br>\s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。<br>\S 匹配非空格的字符，相当于[^\t\r\n\v\f]。<br>\b 匹配词的边界。<br>\B 匹配非词边界，即在词的内部。</li>
</ul>
</li>
<li>JSON格式 简单值分为四种：字符串、数值（必须以十进制表示）、布尔值和null（NaN, Infinity, -Infinity和undefined都会被转为null）</li>
<li>ES5新增了JSON对象，用来处理JSON格式数据。它有两个方法：JSON.stringify和JSON.parse</li>
<li>JSON.stringify方法还可以接受一个数组参数，指定需要转成字符串的属性。</li>
<li>JSON.stringify方法还可以接受一个函数作为参数，用来更改默认的字符串化的行为。</li>
<li>JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。</li>
<li>类型化数组 类型化数组是建立在ArrayBuffer对象的基础上的。它的作用是，分配一段可以存放数据的连续内存区域。</li>
<li>Int8Array：8位有符号整数，长度1个字节 Uint8Array：8位无符号整数，长度1个字节。 等</li>
<li>应用 Ajax 传统上，服务器通过Ajax操作只能返回文本数据。XMLHttpRequest</li>
<li>第二版允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。xhr.responseType = ‘arraybuffer’;</li>
<li>readyState属性 ： 0 请求未初始化，open没调用 1 服务器连接已建立，open已经调用 2 请求已接受，即接收到头信息 3请求处理中，即接收到响应主体 4请求已完成</li>
</ul>
<h2 id="面向对象编程">面向对象编程</h2><ul>
<li>JavaScript语言没有“类”，而改用构造函数（constructor）作为对象的模板。</li>
<li>所谓“构造函数”，就是专门用来生成“对象”的函数。</li>
<li>构造函数的最大特点就是，函数体内部使用了this关键字，代表了所要生成的对象实例。生成对象的时候，必需用new命令</li>
<li>new命令的作用，就是执行构造函数，返回一个实例对象</li>
<li>instanceof运算符用来确定一个对象是否为某个构造函数的实例</li>
<li>this就是指函数当前的运行环境</li>
<li><p>构造函数中的this，指的是实例对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o2.f = o1.f</span><br><span class="line">o2.f() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">o2.f = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123; o1.f() &#125;;</span><br><span class="line">o2.f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有时，某个方法位于多层对象的内部，这时如果为了简化书写，把该方法赋值给一个变量，往往会得到意想不到的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">        b : &#123;</span><br><span class="line">            m : <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">            &#125;,</span><br><span class="line">            p : <span class="string">'Hello'</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = a.b.m;</span><br><span class="line">hello() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码表示，m属于多层对象内部的一个方法。为求简写，将其赋值给hello变量，结果调用时，this指向了全局对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = a.b;</span><br><span class="line">hello.m() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>在Node.js中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。</li>
<li>避免数组处理方法中的this 其实是指向window对象</li>
<li>避免回调函数中的this</li>
<li>固定this的方法 JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向。</li>
<li><p>找出数组最大元素的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定回调函数的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">o.f = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    o.f.apply(o);</span><br><span class="line">    <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#button"</span>).on(<span class="string">"click"</span>, f);</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向全局对象（在浏览器中为window）。它比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。</p>
</li>
<li><p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。<code>element.addEventListener(&#39;click&#39;, o.m.bind(o));</code>上面代码表示，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定。正确的写法是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = o.m.bind(o);</span><br><span class="line">element.addEventListener(<span class="string">'click'</span>, listener);</span><br><span class="line"><span class="comment">//  ...</span></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>, listener);</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery的$.proxy方法，它与bind方法的作用基本相同。</p>
</li>
<li>在JavaScript语言中，每一个对象都有一个对应的原型对象，被称为prototype对象。定义在原型对象上的所有属性和方法，都能被派生对象继承。这就是JavaScript继承机制的基本设计。</li>
<li>构造函数是一个函数，同时也是一个对象，也有自己的属性和方法，其中有一个prototype属性指向另一个对象，一般称为prototype对象。该对象非常特别，只要定义在它上面的属性和方法，能被所有实例对象共享。也就是说，构造函数生成实例对象时，自动为实例对象分配了一个prototype属性</li>
<li>Object.getPrototypeOf方法返回一个对象的原型</li>
<li><p>Object.create方法用于生成新的对象，可以替代new命令。它接受一个原型对象作为参数，返回一个新对象，后者完全继承前者的属性。Object.create方法基本等同于下面的代码，如果老式浏览器不支持Object.create方法，可以用下面代码自己部署。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于Object.create方法不使用构造函数，所以不能用instanceof运算符判断，对象是哪一个构造函数的实例。这时，可以使用isPrototypeOf方法，判读原型是哪一个对象</p>
</li>
<li><p>除了IE浏览器，其他浏览器都在Object对象的实例上，部署了一个非标准的<em>proto</em>属性（前后各两个下划线），指向该对象的原型对象，即构造函数的prototype属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.__proto__ === o.constructor.prototype</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个实例对象的原型，直接的方法是<code>o.proto_，间接的方法是o.constructor.prototype</code>。获取对象原型还有第三种方法，就是使用Object.getPrototypeOf方法</p>
</li>
<li>对象本身的所有属性，可以用Object.getOwnPropertyNames方法获得。</li>
<li>判断一个对象是否具有某个属性（不管是自身的还是继承的），使用in运算符。</li>
<li>获得对象的所有可枚举属性（不管是自身的还是继承的），可以使用for-in循环</li>
</ul>
<h2 id="DOM">DOM</h2><ul>
<li>DOM是文档对象模型（Document Object Model）的简称，它的基本思想是把结构化文档（比如HTML和XML）解析成一系列的节点，再由这些节点组成一个树状结构。目前的通用版本是DOM 3</li>
<li>document对象是文档的根节点 document.childNodes属性返回该对象的所有子节点 对于HTML文档来说，document对象一般有两个子节点。<code>document.doctype</code>  <code>document.documentElement</code></li>
<li>document对象的方法 document.write() 如果在页面已经渲染完成的情况下调用这个方法，会把原有的页面全部抹去，等于是在一个新建的页面上写入内容。为了避免这种情况，一般document.write只能在页面渲染的过程中使用。</li>
<li>querySelector() querySelectorAll() 可以接受各种复杂的CSS选择器</li>
<li>createElement()，createTextNode()</li>
<li>nodeName属性返回节点的名称，nodeType属性返回节点的常数值</li>
<li>nodeValue属性</li>
<li>childNodes属性和children属性</li>
<li>insertBefore()用于将子节点插入父节点的指定位置。它在父节点上调用，接受两个参数，第一个参数是所要插入的子节点，第二个参数是父节点下方的另一个子节点，新插入的子节点将插在这个节点的前面。</li>
<li>当使用querySelectorAll()方法选择一组对象时，会返回一个NodeList对象（比如document.querySelectorAll(‘星号’)的返回结果）或者HTMLCollection对象（比如document.scripts）。它们是类似数组的对象，即可以使用length属性，但是不能使用pop或push之类数组特有的方法。</li>
<li>Element对象 innerHTML属性，outerHTML属性，textContent属性，innerText属性，outerText属性</li>
<li>textcontent属性的作用与innerText属性很相近，但是有以下几点区别：<blockquote>
<p>innerText受CSS影响，textcontent没有这个问题。比如，如果CSS规则隐藏了某段文本，innerText就不会返回这段文本，textcontent则照样返回。<br>innerText返回的文本，会过滤掉空格、换行和回车键，textcontent则不会。<br>innerText属性不是DOM标准的一部分，Firefox浏览器甚至没有部署这个属性，而textcontent是DOM标准的一部分。</p>
</blockquote>
</li>
<li>className属性和classList属性</li>
<li>html元素是网页的根元素，document.documentElement就指向这个元素。</li>
<li>insertAdjacentHTML</li>
<li>getBoundingClientRect方法返回一个记录了位置信息的对象，用于获取HTML元素相对于视口（viewport）左上角的位置以及本身的长度和宽度。</li>
<li>document对象的createDocumentFragment方法可以创建DocumentFragment节点</li>
<li>load事件，error事件</li>
<li>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能使得load和error事件的回调函数根本不会被执行。所以，比较可靠的方式，是用complete属性先判断一下是否加载完成。</li>
<li><p>beforeunload事件 该事件在用户关闭网页时触发。它可以用来防止用户不当心关闭网页。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (textarea.value != textarea.defaultValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你确认要离开吗？'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>abort事件 资源在加载成功前停止加载时触发该事件，主要发生在element、XMLHttpRequest、XMLHttpRequestUpload对象。</p>
</li>
<li>scroll事件 用户滚动窗口或某个元素时触发该事件，主要发生在element、document、window对象。</li>
<li>contextmenu事件</li>
<li>mouseout事件 鼠标移出某个HTML元素时触发。它与mouseleave事件类似，区别在于mouseout事件会冒泡，而且它会在从该元素移入某个子元素时触发。</li>
<li>keydown事件 用户按下某个键时触发，此时用户还没放开这个键。它的触发时间早于系统输入法接收到用户的动作。键盘上的任何键都可以触发该事件。</li>
<li><p>捕捉用户按下Ctrl+H键的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'keydown'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.ctrlKey &amp;&amp; event.which === <span class="number">72</span>) &#123;</span><br><span class="line">    <span class="comment">// open help widget</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>window、body、frame对象的特有事件 包括 hashchange messsage pageshow，pagehide</p>
</li>
<li>document对象的特有事件<ul>
<li>readystatechange事件在readyState属性发生变化时触发。它的发生对象是document和XMLHttpRequest对象</li>
<li>DOMContentLoaded事件在网页解析完成时触发，此时各种外部资源（resource）还没有被完全下载。也就是说，这个事件比load事件，发生时间早得多</li>
</ul>
</li>
<li>拖拉事件 drag dragover drop等</li>
<li>CSS事件 transitionEnd事件 CSS变动的过渡（transition）结束后，触发该事件。 animationstart事件，animationend事件，animationiteration事件</li>
<li>event对象 IE8及以下版本，这个事件对应是不作为参数传递的，而是通过window对象的event属性读取</li>
<li><p>使用浏览器原生方法创造自定义事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line">event.initEvent(<span class="string">'my-custom-event'</span>, <span class="literal">true</span>, <span class="literal">true</span>, &#123;foo:<span class="string">'bar'</span>&#125;);</span><br><span class="line">someElement.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，document.createEvent方法不是标准，只是浏览器还继续支持。目前的标准方法，是使用CustomEvent构造函数，自定义事件对象。除了IE以外的其他浏览器，都支持这种方法。 定义事件对象以后，就可以用addEventListener方法为该事件指定回调函数，用dispatchEvent方法触发该事件。</p>
</li>
<li>style对象的cssText属性 可以用来读写或删除整个style属性。</li>
<li>比较普遍适用的方法是，判断某个DOM元素的style对象的某个属性值是否为字符串。</li>
<li>style对象有以下三个方法，也可以用来设置、读取和删除行内CSS规则，而且不必改写CSS规则名。setPropertyValue，getPropertyValue，removeProperty</li>
<li>DOM元素的style对象无法读写伪元素的样式，这时就要用到window对象的getComputedStyle方法 <code>window.getComputedStyle(test, &#39;:before&#39;).content</code></li>
<li>获取样式表 document.styleSheets == document.querySelector(‘#linkElement’).sheet</li>
<li>getComputedStyle方法只能读取CSS属性，而不能设置。它使用骆驼拼写法表示CSS规则名</li>
<li>window.matchMedia方法用来检查CSS的mediaQuery语句</li>
<li>网页元素的draggable属性 如果网页元素的draggable属性为true，这个元素就是可以拖动的。</li>
<li><p>拖放文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(<span class="string">'drop'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    e.preventDefault();</span><br><span class="line">    e.stopPropagation();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fileList = e.dataTransfer.files;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileList.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> file = fileList[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        reader.onloadend = <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.target.readyState == FileReader.DONE) &#123;</span><br><span class="line">                <span class="keyword">var</span> content = reader.result;</span><br><span class="line">                contentDiv.innerHTML = <span class="string">"File: "</span> + file.name + <span class="string">"\n\n"</span> + content;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reader.readAsBinaryString(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义网页元素的名称中必须含有连字符（-）</p>
</li>
<li>在使用自定义元素前，必须用document对象的registerElement方法登记该元素，registerElement方法返回一个这个自定义元素的构造函数。</li>
<li>Mutation Observer（变动观察器）是监视DOM变动的接口。当DOM对象树发生任何变动的时候，Mutation Observer会得到通知。</li>
</ul>
<h2 id="浏览器对象">浏览器对象</h2><ul>
<li>如果脚本文件使用了非英语字符，还应该注明编码。<code>&lt;script charset=&quot;utf-8&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></li>
<li>Event Loop线程  </li>
<li>setTimeout共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。IE9级以下只支持两个</li>
<li>如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。一种解决方法是将user.sayHi放在函数中执行。另一种解决方法是，使用bind方法，将绑定sayHi绑定在user上面。</li>
<li><p>debounce 防抖动</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span><span class="params">(fn, delay)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 声明计时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setIntervel具有累积效应，如果某个操作特别耗时，超过了setInterval的时间间隔，排在后面的操作会被累积起来，然后在很短的时间内连续触发</p>
</li>
<li>setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务（脚本的同步任务和“任务队列”中已有的事件）一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。</li>
<li>根据HTML 5标准，setTimeOut推迟执行的时间，最少是4毫秒,最多只能推迟执行2147483647毫秒（24.8天）</li>
<li>window.innerHeight属性，window.innerWidth属性 包括滚动条的高度和宽度</li>
<li>window.pageXOffset属性返回页面的水平滚动距离，window.pageYOffset属性返回页面的垂直滚动距离</li>
<li>window.frames[0].contentWindow window.parent</li>
<li>Window对象的Navigator属性，指向一个包含浏览器相关信息的对象。</li>
<li>screen对象 screen.height screen.width</li>
<li>浏览器脚本发生错误时，会触发window对象的error事件 参数：出错信息，出错脚本的网址，行号，列号，错误对象</li>
<li>Access-Control-Allow-Origin的HTTP头信息 在网页的script标签中设置crossorigin属性 CDN脚本报错跨域</li>
<li>window对象的方法 getComputedStyle matchMedia alert confirm prompt</li>
<li>XHR 2之中，send方法可以发送许多类型的数据 Blob类型可以用来发送二进制数据，这使得通过Ajax上传文件成为可能。FormData类型可以用于构造表单数据。</li>
<li>progress事件 上传文件时，XMLHTTPRequest对象的upload属性有一个progress，会不断返回上传的进度。</li>
<li>setRequestHeader方法 responseType属性</li>
<li><code>&lt;input type=&quot;file&quot; id=&quot;file-select&quot; name=&quot;photos[]&quot; multiple/&gt;</code> file控件的multiple属性，指定可以一次选择多个文件；</li>
<li><p>使用FormData接口上传，也可以直接使用File API上传</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'test-input'</span>).files[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'myserver/uploads'</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, file.type);</span><br><span class="line">xhr.send(file);</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery的getJSON方法就是JSONP的一个应用</p>
</li>
<li>CORS的全称是“跨域资源共享”（Cross-origin resource sharing）</li>
<li>CORS机制默认不发送cookie和HTTP认证信息，除非在Ajax请求中打开withCredentials属性 时，服务器返回HTTP头信息时，也必须打开Access-Control-Allow-Credentials选项</li>
<li>targetWindow.postMessage(message, targetURL[, transferObject]); window.addEventListener(“message”) 内部 event.origin event.data event.source</li>
<li>所有浏览器都支持这个方法，但是IE 8和IE 9只允许postMessage方法与iFrame窗口通信，不能与新窗口通信。IE 10允许与新窗口通信，但是只能使用IE特有的MessageChannel对象</li>
<li>IndexedDB就是浏览器端数据库 数据库类型而言，IndexedDB不属于关系型数据库（不支持SQL查询语句），更接近NoSQL数据库</li>
<li>new Notification 通知对象 notification.close();关闭</li>
<li>作为构造函数，Notification有一个permission属性，用于读取用户给于的权限。它可以取三个值。<ol>
<li>denied：用户不接受通知。</li>
<li>granted：用户同意接受通知。</li>
<li>default：用户的选择未知。</li>
</ol>
</li>
<li>Performance API用于精确度量、控制、增强浏览器的性能表现。这个API为测量网站性能，提供以前没有办法做到的精度。</li>
<li>performance.now方法返回当前网页自从performance.timing.navigationStart到当前时间之间的微秒数（毫秒的千分之一）。也就是说，它的精度可以达到100万分之一秒。</li>
<li>移动设备API<ul>
<li>viewport Viewport指的是网页的显示区域，也就是不借助滚动条的情况下，用户可以看到的部分网页大小，中文译为“视口”。正常情况下，viewport和浏览器的显示窗口是一样大小的。但是，在移动设备上，两者可能不是一样大小。</li>
<li>navigator.geolocation navigator.geolocation.getCurrentPosition(geoSuccess,geoError); getCurrentPosition方法还可以接受一个对象作为第三个参数，用来设置定位行为。</li>
<li>navigator.vibrate</li>
<li>Orientation API用于检测手机的摆放方向（竖放或横放） window.addEventListener(“deviceorientation”, callback);</li>
</ul>
</li>
</ul>
<h2 id="HTML网页的API">HTML网页的API</h2><ul>
<li>SVG本质上是文本文件，格式采用XML，可以在浏览器中显示出矢量图像。由于结构是XML格式，使得它可以插入HTML文档，成为DOM的一部分，然后用JavaScript和CSS进行操作。type=”image/svg+xml”<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">svg</span> <span class="attribute">width</span>=<span class="value">"300"</span> <span class="attribute">height</span>=<span class="value">"180"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">circle</span> <span class="attribute">cx</span>=<span class="value">"150"</span> <span class="attribute">cy</span>=<span class="value">"50"</span> <span class="attribute">r</span>=<span class="value">"25"</span> <span class="attribute">class</span>=<span class="value">"fancy"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.fancy</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">fill</span>:<span class="value"> none</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">stroke</span>:<span class="value"> black</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">stroke-width</span>:<span class="value"> <span class="number">3pt</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>line、rect、ellipse、polygon和path标签，分别表示线条、矩形、椭圆、多边形和路径。</li>
<li>每个input输入框都有willValidate属性，表示是否开启表单验证。</li>
<li>历史上，JavaScript无法处理二进制数据。如果一定要处理的话，只能使用charCodeAt()方法，一个个字节地从文字编码转成二进制数据，还有一种办法是将二进制数据转成Base64编码</li>
<li>ECMAScript 5引入了Blob对象，允许直接操作二进制数据。</li>
<li><p>Blob对象是一个代表二进制数据的基本对象，在它的基础上，又衍生出一系列相关的API，用来操作文件。 File对象 FileList对象 FileReader对象 URL对象：用于对二进制数据生成URL</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">"Hello World"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">a.href = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">a.download = <span class="string">"hello-world.txt"</span>;</span><br><span class="line">a.textContent = <span class="string">"Download Hello World!"</span>;</span><br><span class="line"></span><br><span class="line">body.appendChild(a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>同页面的Web Worker 子线程载入的是一个单独的JavaScript文件，但是也可以载入与主线程在同一个网页的代码。 <code>&lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">document</span>.querySelector(<span class="string">'#worker'</span>).textContent]);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动worker。<code>worker.postMessage(&#39;&#39;);</code></p>
</li>
<li>服务器发送事件（Server-Sent Events，简称SSE）就是为了解决这个问题，而提出的一种新API，部署在EventSource对象上。目前，除了IE，其他主流浏览器都支持。</li>
<li>PageVisibility API用于判断页面是否处于浏览器的当前窗口，即是否可见 这个API部署在document对象上，提供以下两个属性。<code>document.hidden</code> <code>document.visibilityState</code> 当页面的可见状态发生变化时，会触发VisibilityChange事件（带有浏览器前缀）</li>
<li>全屏 element.requestFullscreen 使用的时候，可以针对整个网页，也可以针对某个网页元素  document.exitFullscreen</li>
<li>全屏状态的CSS 大多数浏览器的CSS支持:full-screen伪类，只有IE11支持:fullscreen伪类</li>
<li><p>Web Speech用于浏览器接收语音输入。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"query"</span> <span class="attribute">type</span>=<span class="value">"search"</span> <span class="attribute">class</span>=<span class="value">"k-input k-textbox"</span></span><br><span class="line"> <span class="attribute">x-webkit-speech</span> <span class="attribute">speech</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。代码中使用这个API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘。</p>
</li>
<li>requestAnimationFrame的优势，在于充分利用显示器的刷新机制，比较节省系统资源。</li>
<li>WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的通信。WebSocket不使用HTTP协议，而是使用自己的协议</li>
<li>WebRTC是“网络实时通信”（Web Real Time Communication）的缩写</li>
<li>各种网站往往需要一些相同的模块，比如日历、调色板等等，这种模块就被称为“组件”（component）。Web Component就是网页组件式开发的技术规范。</li>
<li>所谓Shadow DOM指的是，浏览器将模板、样式表、属性、JavaScript代码等，封装成一个独立的DOM元素。外部的设置无法影响到其内部，而内部的设置也不会影响到外部，与浏览器处理原生网页元素（比如<video>元素）的方式很像。Shadow DOM最大的好处有两个，一是可以向用户隐藏细节，直接提供组件，二是可以封装内部样式表，不会影响到外部。</video></li>
<li>Shadow DOM元素需要通过createShadowRoot方法创造</li>
</ul>
<h2 id="jQuery">jQuery</h2><ul>
<li>jQuery插件 $.fn 在插件内部，this关键字指的是jQuery对象的实例。而在一般的jQuery回调函数之中，this关键字指的是DOM对象</li>
<li>有时，还可以把顶层对象（window）作为参数输入，这样可以加快代码的执行速度和执行更有效的最小化操作</li>
<li><p>代码的最前面有一个分号，这是为了防止多个脚本文件合并时，其他脚本的结尾语句没有添加分号，造成运行时错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="params">($)</span></span>&#123;</span><br><span class="line">  $.fn.maxHeight = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 下面这个this，指的是jQuery对象实例</span></span><br><span class="line">    <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 回调函数内部，this指的是DOM对象</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, $(<span class="keyword">this</span>).height());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery-free的原生替代方法</p>
</li>
</ul>
<h2 id="开发工具">开发工具</h2><h2 id="高级语法">高级语法</h2><ul>
<li>ES6<ul>
<li>let变量声明</li>
<li>const常量</li>
<li>新数据结构Set,Map</li>
<li>rest, 遍历器</li>
<li>generator</li>
<li>箭头定义函数</li>
<li>class extends</li>
<li>import module</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/06/Javascript标准参考教材摘记/" data-id="ci6x7cbj200019shqfz3s98ea" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/03/06/Javascript标准参考教材摘记/">Javascript标准参考教材摘记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Love11zi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>